local StrucidBR = Instance.new("ScreenGui")
local main = Instance.new("Frame")
local hitboxextender = Instance.new("TextButton")
local removemap = Instance.new("TextButton")
local noclip = Instance.new("TextButton")
local ctrlclicktp = Instance.new("TextButton")
local ESP = Instance.new("TextButton")
local infjump = Instance.new("TextButton")
local aimlock = Instance.new("TextButton")
local size = Instance.new("TextBox")
local title = Instance.new("TextLabel")
local close = Instance.new("TextButton")
local open = Instance.new("TextButton")

StrucidBR.Name = "StrucidBR"
StrucidBR.Parent = game.CoreGui
StrucidBR.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

main.Name = "main"
main.Parent = StrucidBR
main.Active = true
main.Draggable = true
main.BackgroundColor3 = Color3.new(0.792157, 0.0431373, 1)
main.BorderSizePixel = 0
main.Position = UDim2.new(0.281212121, 0, 0.259213746, 0)
main.Size = UDim2.new(0, 437, 0, 268)

hitboxextender.Name = "hitboxextender"
hitboxextender.Parent = main
hitboxextender.BackgroundColor3 = Color3.new(1, 1, 1)
hitboxextender.BackgroundTransparency = 1
hitboxextender.Position = UDim2.new(0.49866575, 0, 0.227611944, 0)
hitboxextender.Size = UDim2.new(0, 217, 0, 63)
hitboxextender.Font = Enum.Font.GothamSemibold
hitboxextender.Text = "Extend Hitbox"
hitboxextender.TextColor3 = Color3.new(0, 0, 0)
hitboxextender.TextScaled = true
hitboxextender.TextSize = 14
hitboxextender.TextStrokeColor3 = Color3.new(0.298039, 1, 0)
hitboxextender.TextStrokeTransparency = 0
hitboxextender.TextWrapped = true

removemap.Name = "removemap"
removemap.Parent = main
removemap.BackgroundColor3 = Color3.new(1, 1, 1)
removemap.BackgroundTransparency = 1
removemap.Position = UDim2.new(0.665141046, 0, 0.730099559, 0)
removemap.Size = UDim2.new(0, 145, 0, 72)
removemap.Font = Enum.Font.GothamSemibold
removemap.Text = "Remove Map"
removemap.TextColor3 = Color3.new(0, 0, 0)
removemap.TextScaled = true
removemap.TextSize = 14
removemap.TextStrokeColor3 = Color3.new(0.298039, 1, 0)
removemap.TextStrokeTransparency = 0
removemap.TextWrapped = true

noclip.Name = "noclip"
noclip.Parent = main
noclip.BackgroundColor3 = Color3.new(1, 1, 1)
noclip.BackgroundTransparency = 1
noclip.Position = UDim2.new(0.666666746, 0, 0.465174198, 0)
noclip.Size = UDim2.new(0, 145, 0, 71)
noclip.Font = Enum.Font.GothamSemibold
noclip.Text = "Noclip"
noclip.TextColor3 = Color3.new(0, 0, 0)
noclip.TextScaled = true
noclip.TextSize = 14
noclip.TextStrokeColor3 = Color3.new(0.298039, 1, 0)
noclip.TextStrokeTransparency = 0
noclip.TextWrapped = true

ctrlclicktp.Name = "ctrlclicktp"
ctrlclicktp.Parent = main
ctrlclicktp.BackgroundColor3 = Color3.new(1, 1, 1)
ctrlclicktp.BackgroundTransparency = 1
ctrlclicktp.Position = UDim2.new(0.333333373, 0, 0.465174198, 0)
ctrlclicktp.Size = UDim2.new(0, 145, 0, 71)
ctrlclicktp.Font = Enum.Font.GothamSemibold
ctrlclicktp.Text = "CTRL Click TP"
ctrlclicktp.TextColor3 = Color3.new(0, 0, 0)
ctrlclicktp.TextScaled = true
ctrlclicktp.TextSize = 14
ctrlclicktp.TextStrokeColor3 = Color3.new(0.298039, 1, 0)
ctrlclicktp.TextStrokeTransparency = 0
ctrlclicktp.TextWrapped = true

ESP.Name = "ESP"
ESP.Parent = main
ESP.BackgroundColor3 = Color3.new(1, 1, 1)
ESP.BackgroundTransparency = 1
ESP.Position = UDim2.new(0, 0, 0.465174198, 0)
ESP.Size = UDim2.new(0, 145, 0, 71)
ESP.Font = Enum.Font.GothamSemibold
ESP.Text = "ESP"
ESP.TextColor3 = Color3.new(0, 0, 0)
ESP.TextScaled = true
ESP.TextSize = 14
ESP.TextStrokeColor3 = Color3.new(0.298039, 1, 0)
ESP.TextStrokeTransparency = 0
ESP.TextWrapped = true

infjump.Name = "infjump"
infjump.Parent = main
infjump.BackgroundColor3 = Color3.new(1, 1, 1)
infjump.BackgroundTransparency = 1
infjump.Position = UDim2.new(0, 0, 0.732587099, 0)
infjump.Size = UDim2.new(0, 145, 0, 71)
infjump.Font = Enum.Font.GothamSemibold
infjump.Text = "Inf Jump"
infjump.TextColor3 = Color3.new(0, 0, 0)
infjump.TextScaled = true
infjump.TextSize = 14
infjump.TextStrokeColor3 = Color3.new(0.298039, 1, 0)
infjump.TextStrokeTransparency = 0
infjump.TextWrapped = true

aimlock.Name = "aimlock"
aimlock.Parent = main
aimlock.BackgroundColor3 = Color3.new(1, 1, 1)
aimlock.BackgroundTransparency = 1
aimlock.Position = UDim2.new(0.330282331, 0, 0.735074639, 0)
aimlock.Size = UDim2.new(0, 146, 0, 71)
aimlock.Font = Enum.Font.GothamSemibold
aimlock.Text = "Aimlock"
aimlock.TextColor3 = Color3.new(0, 0, 0)
aimlock.TextScaled = true
aimlock.TextSize = 14
aimlock.TextStrokeColor3 = Color3.new(0.298039, 1, 0)
aimlock.TextStrokeTransparency = 0
aimlock.TextWrapped = true

size.Name = "size"
size.Parent = main
size.BackgroundColor3 = Color3.new(1, 1, 1)
size.BackgroundTransparency = 0.5
size.BorderSizePixel = 0
size.Position = UDim2.new(-0.000762729964, 0, 0.227611944, 0)
size.Size = UDim2.new(0, 216, 0, 63)
size.Font = Enum.Font.GothamBlack
size.Text = "Hitbox Size Here :)"
size.TextColor3 = Color3.new(0, 0, 0)
size.TextSize = 14
size.TextStrokeColor3 = Color3.new(0.45098, 1, 0)
size.TextStrokeTransparency = 0
size.TextWrapped = true

title.Name = "title"
title.Parent = main
title.BackgroundColor3 = Color3.new(1, 1, 1)
title.BackgroundTransparency = 1
title.Size = UDim2.new(0, 437, 0, 61)
title.Font = Enum.Font.GothamBold
title.Text = "STRUCID FUCKER (By RoHub)"
title.TextColor3 = Color3.new(0, 0, 0)
title.TextScaled = true
title.TextSize = 14
title.TextWrapped = true

close.Name = "close"
close.Parent = main
close.BackgroundColor3 = Color3.new(1, 1, 1)
close.BackgroundTransparency = 1
close.Position = UDim2.new(0.956521749, 0, 0, 0)
close.Size = UDim2.new(0, 19, 0, 17)
close.Text = "X"
close.TextColor3 = Color3.new(0, 0, 0)
close.TextScaled = true
close.TextSize = 14
close.TextWrapped = true

open.Name = "open"
open.Parent = StrucidBR
open.BackgroundColor3 = Color3.new(0.835294, 0, 1)
open.Position = UDim2.new(0, 0, 0.652334154, 0)
open.Size = UDim2.new(0, 164, 0, 56)
open.Font = Enum.Font.GothamBlack
open.Text = "OPEN"
open.TextColor3 = Color3.new(0, 0, 0)
open.TextScaled = true
open.TextSize = 14
open.TextStrokeColor3 = Color3.new(0.180392, 1, 0)
open.TextStrokeTransparency = 0
open.TextWrapped = true
open.Visible = false
open.MouseButton1Down:connect(function()
main.Visible = true
open.Visible = false
end)
close.MouseButton1Down:connect(function()
main.Visible = false
open.Visible = true
end)
hitboxextender.MouseButton1Down:connect(function()
_G.HeadSize = (size.Text)
_G.Disabled = true

game:GetService('RunService').RenderStepped:connect(function()
if _G.Disabled then
for i,v in next, game:GetService('Players'):GetPlayers() do
if v.Name ~= game:GetService('Players').LocalPlayer.Name then
pcall(function()
v.Character.HumanoidRootPart.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize)
v.Character.HumanoidRootPart.Transparency = 0.6
v.Character.HumanoidRootPart.BrickColor = BrickColor.new("Really blue")
v.Character.HumanoidRootPart.Material = "SmoothPlastic"
v.Character.HumanoidRootPart.CanCollide = false
end)
end
end
end
end)
end)
infjump.MouseButton1Down:connect(function()
game:GetService("UserInputService").JumpRequest:connect(function()game:GetService"Players".LocalPlayer.Character:FindFirstChildOfClass'Humanoid':ChangeState("Jumping")end)
end)
ESP.MouseButton1Down:connect(function()
-- Created By Ic3W0lf
assert(Drawing, 'exploit not supported')

local UserInputService = game:GetService'UserInputService';
local HttpService = game:GetService'HttpService';
local GUIService = game:GetService'GuiService';
local RunService = game:GetService'RunService';
local Players = game:GetService'Players';
local LocalPlayer = Players.LocalPlayer;
local Camera = workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse();
local Menu = {};
local MouseHeld = false;
local LastRefresh = 0;
local OptionsFile = 'IC3_ESP_SETTINGS.dat';
local Binding = false;
local BindedKey = nil;
local OIndex = 0;
local LineBox = {};
local UIButtons = {};
local Sliders = {};
local Dragging = false;
local DraggingUI = false;
local DragOffset = Vector2.new();
local DraggingWhat = nil;
local OldData = {};
local IgnoreList = {};
local Red = Color3.new(1, 0, 0);
local Green = Color3.new(0, 1, 0);
local MenuLoaded = false;

shared.MenuDrawingData = shared.MenuDrawingData or { Instances = {} };
shared.PlayerData = shared.PlayerData or {};
shared.RSName = shared.RSName or ('UnnamedESP_by_ic3-' .. HttpService:GenerateGUID(false));

local GetDataName = shared.RSName .. '-GetData';
local UpdateName = shared.RSName .. '-Update';

local Debounce = setmetatable({}, {
__index = function(t, i)
return rawget(t, i) or false
end;
});

pcall(function() shared.InputBeganCon:disconnect() end);
pcall(function() shared.InputEndedCon:disconnect() end);

function GetMouseLocation()
return UserInputService:GetMouseLocation();
end

function MouseHoveringOver(Values)
local X1, Y1, X2, Y2 = Values[1], Values[2], Values[3], Values[4]
local MLocation = GetMouseLocation();
return (MLocation.x >= X1 and MLocation.x <= (X1 + (X2 - X1))) and (MLocation.y >= Y1 and MLocation.y <= (Y1 + (Y2 - Y1)));
end

function GetTableData(t) -- basically table.foreach i dont even know why i made this
if typeof(t) ~= 'table' then return end
return setmetatable(t, {
__call = function(t, func)
if typeof(func) ~= 'function' then return end;
for i, v in pairs(t) do
pcall(func, i, v);
end
end;
});
end
local function Format(format, ...)
return string.format(format, ...);
end
function CalculateValue(Min, Max, Percent)
return Min + math.floor(((Max - Min) * Percent) + .5);
end

local Options = setmetatable({}, {
__call = function(t, ...)
local Arguments = {...};
local Name = Arguments[1];
OIndex = OIndex + 1; -- (typeof(Arguments[3]) == 'boolean' and 1 or 0);
rawset(t, Name, setmetatable({
Name = Arguments[1];
Text = Arguments[2];
Value = Arguments[3];
DefaultValue = Arguments[3];
AllArgs = Arguments;
Index = OIndex;
}, {
__call = function(t, v)
if typeof(t.Value) == 'function' then
t.Value();
elseif typeof(t.Value) == 'EnumItem' then
local BT = Menu:GetInstance(Format('%s_BindText', t.Name));
Binding = true;
local Val = 0
while Binding do
wait();
Val = (Val + 1) % 17;
BT.Text = Val <= 8 and '|' or '';
end
t.Value = BindedKey;
BT.Text = tostring(t.Value):match'%w+%.%w+%.(.+)';
BT.Position = t.BasePosition + Vector2.new(t.BaseSize.X - BT.TextBounds.X - 20, -10);
else
local NewValue = v;
if NewValue == nil then NewValue = not t.Value; end
rawset(t, 'Value', NewValue);
if Arguments[2] ~= nil then
if typeof(Arguments[3]) == 'number' then
local AMT = Menu:GetInstance(Format('%s_AmountText', t.Name));
AMT.Text = tostring(t.Value);
AMT.Position = t.BasePosition + Vector2.new(t.BaseSize.X - AMT.TextBounds.X - 10, -10);
else
local Inner = Menu:GetInstance(Format('%s_InnerCircle', t.Name));
Inner.Visible = t.Value;
end
end
end
end;
}));
end;
})

function Load()
local _, Result = pcall(readfile, OptionsFile);
if _ then -- extremely ugly code yea i know but i dont care p.s. i hate pcall
local _, Table = pcall(HttpService.JSONDecode, HttpService, Result);
if _ then
for i, v in pairs(Table) do
if Options[i] ~= nil and Options[i].Value ~= nil and (typeof(Options[i].Value) == 'boolean' or typeof(Options[i].Value) == 'number') then
Options[i].Value = v.Value;
pcall(Options[i], v.Value);
end
end
end
end
end

Options('Enabled', 'ESP Enabled', true);
Options('ShowTeam', 'Show Team', true);
Options('ShowName', 'Show Names', true);
Options('ShowDistance', 'Show Distance', true);
Options('ShowHealth', 'Show Health', true);
Options('ShowBoxes', 'Show Boxes', true);
Options('ShowTracers', 'Show Tracers', true);
Options('ShowDot', 'Show Head Dot', false);
Options('VisCheck', 'Visibility Check', false);
Options('Crosshair', 'Crosshair', false);
Options('TextOutline', 'Text Outline', true);
Options('TextSize', 'Text Size', syn and 18 or 14, 10, 24); -- cuz synapse fonts look weird???
Options('MaxDistance', 'Max Distance', 2500, 100, 5000);
Options('RefreshRate', 'Refresh Rate (ms)', 5, 1, 200);
Options('MenuKey', 'Menu Key', Enum.KeyCode.F4, 1);
Options('ResetSettings', 'Reset Settings', function()
for i, v in pairs(Options) do
if Options[i] ~= nil and Options[i].Value ~= nil and Options[i].Text ~= nil and (typeof(Options[i].Value) == 'boolean' or typeof(Options[i].Value) == 'number') then
Options[i](Options[i].DefaultValue);
end
end
end, 4);
Options('LoadSettings', 'Load Settings', Load, 3);
Options('SaveSettings', 'Save Settings', function()
writefile(OptionsFile, HttpService:JSONEncode(Options));
end, 2)
-- Options.SaveSettings.Value();

Load();

Options('MenuOpen', nil, true);

local function Set(t, i, v)
t[i] = v;
end
local function Combine(...)
local Output = {};
for i, v in pairs{...} do
if typeof(v) == 'table' then
table.foreach(v, function(i, v)
Output[i] = v;
end)
end
end
return Output
end
function IsStringEmpty(String)
if type(String) == 'string' then
return String:match'^%s+$' ~= nil or #String == 0 or String == '' or false;
end
return false
end

function NewDrawing(InstanceName)
local Instance = Drawing.new(InstanceName);
return (function(Properties)
for i, v in pairs(Properties) do
pcall(Set, Instance, i, v);
end
return Instance;
end)
end

function Menu:AddMenuInstace(Name, Instance)
if shared.MenuDrawingData.Instances[Name] ~= nil then
shared.MenuDrawingData.Instances[Name]:Remove();
end
shared.MenuDrawingData.Instances[Name] = Instance;
return Instance;
end
function Menu:UpdateMenuInstance(Name)
local Instance = shared.MenuDrawingData.Instances[Name];
if Instance ~= nil then
return (function(Properties)
for i, v in pairs(Properties) do
-- print(Format('%s %s -> %s', Name, tostring(i), tostring(v)));
pcall(Set, Instance, i, v);
end
return Instance;
end)
end
end
function Menu:GetInstance(Name)
return shared.MenuDrawingData.Instances[Name];
end

function LineBox:Create(Properties)
local Box = { Visible = true }; -- prevent errors not really though dont worry bout the Visible = true thing

local Properties = Combine({
Transparency = 1;
Thickness = 1;
Visible = true;
}, Properties);

Box['TopLeft'] = NewDrawing'Line'(Properties);
Box['TopRight'] = NewDrawing'Line'(Properties);
Box['BottomLeft'] = NewDrawing'Line'(Properties);
Box['BottomRight'] = NewDrawing'Line'(Properties);

function Box:Update(CF, Size, Color, Properties)
if not CF or not Size then return end

local TLPos, Visible1 = Camera:WorldToViewportPoint((CF * CFrame.new( Size.X,  Size.Y, 0)).p);
local TRPos, Visible2 = Camera:WorldToViewportPoint((CF * CFrame.new(-Size.X,  Size.Y, 0)).p);
local BLPos, Visible3 = Camera:WorldToViewportPoint((CF * CFrame.new( Size.X, -Size.Y, 0)).p);
local BRPos, Visible4 = Camera:WorldToViewportPoint((CF * CFrame.new(-Size.X, -Size.Y, 0)).p);
-- ## BEGIN UGLY CODE
if Visible1 then
Box['TopLeft'].Visible = true;
Box['TopLeft'].Color = Color;
Box['TopLeft'].From = Vector2.new(TLPos.X, TLPos.Y);
Box['TopLeft'].To = Vector2.new(TRPos.X, TRPos.Y);
else
Box['TopLeft'].Visible = false;
end
if Visible2 then
Box['TopRight'].Visible = true;
Box['TopRight'].Color = Color;
Box['TopRight'].From = Vector2.new(TRPos.X, TRPos.Y);
Box['TopRight'].To = Vector2.new(BRPos.X, BRPos.Y);
else
Box['TopRight'].Visible = false;
end
if Visible3 then
Box['BottomLeft'].Visible = true;
Box['BottomLeft'].Color = Color;
Box['BottomLeft'].From = Vector2.new(BLPos.X, BLPos.Y);
Box['BottomLeft'].To = Vector2.new(TLPos.X, TLPos.Y);
else
Box['BottomLeft'].Visible = false;
end
if Visible4 then
Box['BottomRight'].Visible = true;
Box['BottomRight'].Color = Color;
Box['BottomRight'].From = Vector2.new(BRPos.X, BRPos.Y);
Box['BottomRight'].To = Vector2.new(BLPos.X, BLPos.Y);
else
Box['BottomRight'].Visible = false;
end
-- ## END UGLY CODE
if Properties then
GetTableData(Properties)(function(i, v)
pcall(Set, Box['TopLeft'], i, v);
pcall(Set, Box['TopRight'], i, v);
pcall(Set, Box['BottomLeft'], i, v);
pcall(Set, Box['BottomRight'], i, v);
end)
end
end
function Box:SetVisible(bool)
pcall(Set, Box['TopLeft'], 'Visible', bool);
pcall(Set, Box['TopRight'], 'Visible', bool);
pcall(Set, Box['BottomLeft'], 'Visible', bool);
pcall(Set, Box['BottomRight'], 'Visible', bool);
end
function Box:Remove()
self:SetVisible(false);
Box['TopLeft']:Remove();
Box['TopRight']:Remove();
Box['BottomLeft']:Remove();
Box['BottomRight']:Remove();
end

return Box;
end

function CreateMenu(NewPosition) -- Create Menu
local function FromHex(HEX)
HEX = HEX:gsub('#', '');
return Color3.fromRGB(tonumber('0x' .. HEX:sub(1, 2)), tonumber('0x' .. HEX:sub(3, 4)), tonumber('0x' .. HEX:sub(5, 6)));
end

local Colors = {
Primary = {
Main = FromHex'424242';
Light = FromHex'6d6d6d';
Dark = FromHex'1b1b1b';
};
Secondary = {
Main = FromHex'e0e0e0';
Light = FromHex'ffffff';
Dark = FromHex'aeaeae';
};
};

MenuLoaded = false;

GetTableData(UIButtons)(function(i, v)
v.Instance.Visible = false;
v.Instance:Remove();
end)
GetTableData(Sliders)(function(i, v)
v.Instance.Visible = false;
v.Instance:Remove();
end)

UIButtons = {};
Sliders = {};

local BaseSize = Vector2.new(300, 580);
local BasePosition = NewPosition or Vector2.new(Camera.ViewportSize.X / 8 - (BaseSize.X / 2), Camera.ViewportSize.Y / 2 - (BaseSize.Y / 2));

Menu:AddMenuInstace('CrosshairX', NewDrawing'Line'{
Visible = false;
Color = Color3.new(0, 1, 0);
Transparency = 1;
Thickness = 1;
});
Menu:AddMenuInstace('CrosshairY', NewDrawing'Line'{
Visible = false;
Color = Color3.new(0, 1, 0);
Transparency = 1;
Thickness = 1;
});

delay(.025, function() -- since zindex doesnt exist
Menu:AddMenuInstace('Main', NewDrawing'Square'{
Size = BaseSize;
Position = BasePosition;
Filled = false;
Color = Colors.Primary.Main;
Thickness = 3;
Visible = true;
});
end);
Menu:AddMenuInstace('TopBar', NewDrawing'Square'{
Position = BasePosition;
Size = Vector2.new(BaseSize.X, 25);
Color = Colors.Primary.Dark;
Filled = true;
Visible = true;
});
Menu:AddMenuInstace('TopBarTwo', NewDrawing'Square'{
Position = BasePosition + Vector2.new(0, 25);
Size = Vector2.new(BaseSize.X, 60);
Color = Colors.Primary.Main;
Filled = true;
Visible = true;
});
Menu:AddMenuInstace('TopBarText', NewDrawing'Text'{
Size = 25;
Position = shared.MenuDrawingData.Instances.TopBarTwo.Position + Vector2.new(25, 15);
Text = 'Unnamed ESP';
Color = Colors.Secondary.Light;
Visible = true;
});
Menu:AddMenuInstace('TopBarTextBR', NewDrawing'Text'{
Size = 15;
Position = shared.MenuDrawingData.Instances.TopBarTwo.Position + Vector2.new(BaseSize.X - 65, 40);
Text = 'by ic3w0lf';
Color = Colors.Secondary.Dark;
Visible = true;
});
Menu:AddMenuInstace('Filling', NewDrawing'Square'{
Size = BaseSize - Vector2.new(0, 85);
Position = BasePosition + Vector2.new(0, 85);
Filled = true;
Color = Colors.Secondary.Main;
Transparency= .5;
Visible = true;
});

local CPos = 0;

GetTableData(Options)(function(i, v)
if typeof(v.Value) == 'boolean' and not IsStringEmpty(v.Text) and v.Text ~= nil then
CPos = CPos + 25;
local BaseSize = Vector2.new(BaseSize.X, 30);
local BasePosition = shared.MenuDrawingData.Instances.Filling.Position + Vector2.new(30, v.Index * 25 - 10);
UIButtons[#UIButtons + 1] = {
Option = v;
Instance = Menu:AddMenuInstace(Format('%s_Hitbox', v.Name), NewDrawing'Square'{
Position = BasePosition - Vector2.new(30, 15);
Size = BaseSize;
Visible = false;
});
};
Menu:AddMenuInstace(Format('%s_OuterCircle', v.Name), NewDrawing'Circle'{
Radius = 10;
Position = BasePosition;
Color = Colors.Secondary.Light;
Filled = true;
Visible = true;
});
Menu:AddMenuInstace(Format('%s_InnerCircle', v.Name), NewDrawing'Circle'{
Radius = 7;
Position = BasePosition;
Color = Colors.Secondary.Dark;
Filled = true;
Visible = v.Value;
});
Menu:AddMenuInstace(Format('%s_Text', v.Name), NewDrawing'Text'{
Text = v.Text;
Size = 20;
Position = BasePosition + Vector2.new(20, -10);
Visible = true;
Color = Colors.Primary.Dark;
});
end
end)
GetTableData(Options)(function(i, v) -- just to make sure certain things are drawn before or after others, too lazy to actually sort table
if typeof(v.Value) == 'number' then
CPos = CPos + 25;

local BaseSize = Vector2.new(BaseSize.X, 30);
local BasePosition = shared.MenuDrawingData.Instances.Filling.Position + Vector2.new(0, CPos - 10);

local Text = Menu:AddMenuInstace(Format('%s_Text', v.Name), NewDrawing'Text'{
Text = v.Text;
Size = 20;
Position = BasePosition + Vector2.new(20, -10);
Visible = true;
Color = Colors.Primary.Dark;
});
local AMT = Menu:AddMenuInstace(Format('%s_AmountText', v.Name), NewDrawing'Text'{
Text = tostring(v.Value);
Size = 20;
Position = BasePosition;
Visible = true;
Color = Colors.Primary.Dark;
});
local Line = Menu:AddMenuInstace(Format('%s_SliderLine', v.Name), NewDrawing'Line'{
Transparency = 1;
Color = Colors.Primary.Dark;
Thickness = 3;
Visible = true;
From = BasePosition + Vector2.new(20, 20);
To = BasePosition + Vector2.new(BaseSize.X - 10, 20);
});
CPos = CPos + 10;
local Slider = Menu:AddMenuInstace(Format('%s_Slider', v.Name), NewDrawing'Circle'{
Visible = true;
Filled = true;
Radius = 6;
Color = Colors.Secondary.Dark;
Position = BasePosition + Vector2.new(35, 20);
})

local CSlider = {Slider = Slider; Line = Line; Min = v.AllArgs[4]; Max = v.AllArgs[5]; Option = v};
Sliders[#Sliders + 1] = CSlider;

-- local Percent = (v.Value / CSlider.Max) * 100;
-- local Size = math.abs(Line.From.X - Line.To.X);
-- local Value = Size * (Percent / 100); -- this shit's inaccurate but fuck it i'm not even gonna bother fixing it

Slider.Position = BasePosition + Vector2.new(40, 20);

v.BaseSize = BaseSize;
v.BasePosition = BasePosition;
AMT.Position = BasePosition + Vector2.new(BaseSize.X - AMT.TextBounds.X - 10, -10)
end
end)
GetTableData(Options)(function(i, v) -- just to make sure certain things are drawn before or after others, too lazy to actually sort table
if typeof(v.Value) == 'EnumItem' then
CPos = CPos + 30;

local BaseSize = Vector2.new(BaseSize.X, 30);
local BasePosition = shared.MenuDrawingData.Instances.Filling.Position + Vector2.new(0, CPos - 10);

UIButtons[#UIButtons + 1] = {
Option = v;
Instance = Menu:AddMenuInstace(Format('%s_Hitbox', v.Name), NewDrawing'Square'{
Size = Vector2.new(BaseSize.X, 20) - Vector2.new(30, 0);
Visible = true;
Transparency= .5;
Position = BasePosition + Vector2.new(15, -10);
Color = Colors.Secondary.Light;
Filled = true;
});
};
local Text = Menu:AddMenuInstace(Format('%s_Text', v.Name), NewDrawing'Text'{
Text = v.Text;
Size = 20;
Position = BasePosition + Vector2.new(20, -10);
Visible = true;
Color = Colors.Primary.Dark;
});
local BindText = Menu:AddMenuInstace(Format('%s_BindText', v.Name), NewDrawing'Text'{
Text = tostring(v.Value):match'%w+%.%w+%.(.+)';
Size = 20;
Position = BasePosition;
Visible = true;
Color = Colors.Primary.Dark;
});

Options[i].BaseSize = BaseSize;
Options[i].BasePosition = BasePosition;
BindText.Position = BasePosition + Vector2.new(BaseSize.X - BindText.TextBounds.X - 20, -10);
end
end)
GetTableData(Options)(function(i, v) -- just to make sure certain things are drawn before or after others, too lazy to actually sort table
if typeof(v.Value) == 'function' then
local BaseSize = Vector2.new(BaseSize.X, 30);
local BasePosition = shared.MenuDrawingData.Instances.Filling.Position + Vector2.new(0, CPos + (25 * v.AllArgs[4]) - 35);

UIButtons[#UIButtons + 1] = {
Option = v;
Instance = Menu:AddMenuInstace(Format('%s_Hitbox', v.Name), NewDrawing'Square'{
Size = Vector2.new(BaseSize.X, 20) - Vector2.new(30, 0);
Visible = true;
Transparency= .5;
Position = BasePosition + Vector2.new(15, -10);
Color = Colors.Secondary.Light;
Filled = true;
});
};
local Text = Menu:AddMenuInstace(Format('%s_Text', v.Name), NewDrawing'Text'{
Text = v.Text;
Size = 20;
Position = BasePosition + Vector2.new(20, -10);
Visible = true;
Color = Colors.Primary.Dark;
});

-- BindText.Position = BasePosition + Vector2.new(BaseSize.X - BindText.TextBounds.X - 10, -10);
end
end)

delay(.1, function()
MenuLoaded = true;
end);

-- this has to be at the bottom cuz proto drawing api doesnt have zindex :triumph: 
Menu:AddMenuInstace('Cursor1', NewDrawing'Line'{
Visible = false;
Color = Color3.new(1, 0, 0);
Transparency = 1;
Thickness = 2;
});
Menu:AddMenuInstace('Cursor2', NewDrawing'Line'{
Visible = false;
Color = Color3.new(1, 0, 0);
Transparency = 1;
Thickness = 2;
});
Menu:AddMenuInstace('Cursor3', NewDrawing'Line'{
Visible = false;
Color = Color3.new(1, 0, 0);
Transparency = 1;
Thickness = 2;
});
end

CreateMenu();

shared.InputBeganCon = UserInputService.InputBegan:connect(function(input)
if input.UserInputType.Name == 'MouseButton1' and Options.MenuOpen.Value then
MouseHeld = true;
local Bar = Menu:GetInstance'TopBar';
local Values = {
Bar.Position.X;
Bar.Position.Y;
Bar.Position.X + Bar.Size.X;
Bar.Position.Y + Bar.Size.Y;
}
if MouseHoveringOver(Values) and not syn then -- disable dragging for synapse cuz idk why it breaks
DraggingUI = true;
DragOffset = Menu:GetInstance'Main'.Position - GetMouseLocation();
else
for i, v in pairs(Sliders) do
local Values = {
v.Line.From.X - (v.Slider.Radius);
v.Line.From.Y - (v.Slider.Radius);
v.Line.To.X + (v.Slider.Radius);
v.Line.To.Y + (v.Slider.Radius);
};
if MouseHoveringOver(Values) then
DraggingWhat = v;
Dragging = true;
break
end
end
end
end
end)
shared.InputEndedCon = UserInputService.InputEnded:connect(function(input)
if input.UserInputType.Name == 'MouseButton1' and Options.MenuOpen.Value then
MouseHeld = false;
for i, v in pairs(UIButtons) do
local Values = {
v.Instance.Position.X;
v.Instance.Position.Y;
v.Instance.Position.X + v.Instance.Size.X;
v.Instance.Position.Y + v.Instance.Size.Y;
};
if MouseHoveringOver(Values) then
v.Option();
break -- prevent clicking 2 options
end
end
elseif input.UserInputType.Name == 'Keyboard' then
if Binding then
BindedKey = input.KeyCode;
Binding = false;
elseif input.KeyCode == Options.MenuKey.Value or (input.KeyCode == Enum.KeyCode.Home and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)) then
Options.MenuOpen();
end
end
end)

function ToggleMenu()
if Options.MenuOpen.Value then
GetTableData(shared.MenuDrawingData.Instances)(function(i, v)
if OldData[v] then
pcall(Set, v, 'Visible', true);
end
end)
else
-- GUIService:SetMenuIsOpen(false);
GetTableData(shared.MenuDrawingData.Instances)(function(i, v)
if v.Visible == true then
OldData[v] = true;
pcall(Set, v, 'Visible', false);
end
end)
end
end

function CheckRay(Player, Distance, Position, Unit)
local Pass = true;

if Distance > 999 then return false; end

local _Ray = Ray.new(Position, Unit * Distance);

local List = {LocalPlayer.Character, Camera, Mouse.TargetFilter};

for i,v in pairs(IgnoreList) do table.insert(List, v); end;

local Hit = workspace:FindPartOnRayWithIgnoreList(_Ray, List);
if Hit and not Hit:IsDescendantOf(Player.Character) then
Pass = false;
if Hit.Transparency >= .3 or not Hit.CanCollide and Hit.ClassName ~= Terrain then -- Detect invisible walls
IgnoreList[#IgnoreList + 1] = Hit;
end
end

return Pass;
end

function CheckPlayer(Player)
if not Options.Enabled.Value then return false end

local Pass = true;
local Distance = 0;

if Player ~= LocalPlayer and Player.Character then
if not Options.ShowTeam.Value and Player.TeamColor == LocalPlayer.TeamColor then
Pass = false;
end

local Head = Player.Character:FindFirstChild'Head';

if Pass and Player.Character and Head then
Distance = (Camera.CFrame.p - Head.Position).magnitude;
if Options.VisCheck.Value then
Pass = CheckRay(Player, Distance, Camera.CFrame.p, (Head.Position - Camera.CFrame.p).unit);
end
if Distance > Options.MaxDistance.Value then
Pass = false;
end
end
else
Pass = false;
end

return Pass, Distance;
end

function UpdatePlayerData()
if (tick() - LastRefresh) > (Options.RefreshRate.Value / 1000) then
LastRefresh = tick();
for i, v in pairs(Players:GetPlayers()) do
local Data = shared.PlayerData[v.Name] or { Instances = {} };

Data.Instances['Box'] = Data.Instances['Box'] or LineBox:Create{Thickness = 3};
Data.Instances['Tracer'] = Data.Instances['Tracer'] or NewDrawing'Line'{
Transparency = 1;
Thickness = 2;
}
Data.Instances['HeadDot'] = Data.Instances['HeadDot'] or NewDrawing'Circle'{
Filled = true;
NumSides = 30;
}
Data.Instances['NameTag'] = Data.Instances['NameTag'] or NewDrawing'Text'{
Size = Options.TextSize.Value;
Center = true;
Outline = Options.TextOutline.Value;
Visible = true;
};
Data.Instances['DistanceHealthTag'] = Data.Instances['DistanceHealthTag'] or NewDrawing'Text'{
Size = Options.TextSize.Value - 1;
Center = true;
Outline = Options.TextOutline.Value;
Visible = true;
};

local NameTag = Data.Instances['NameTag'];
local DistanceTag = Data.Instances['DistanceHealthTag'];
local Tracer = Data.Instances['Tracer'];
local HeadDot = Data.Instances['HeadDot'];
local Box = Data.Instances['Box'];

local Pass, Distance = CheckPlayer(v);

if Pass and v.Character then
Data.LastUpdate = tick();
local Humanoid = v.Character:FindFirstChildOfClass'Humanoid';
local Head = v.Character:FindFirstChild'Head';
local HumanoidRootPart = v.Character:FindFirstChild'HumanoidRootPart';
if v.Character ~= nil and Head then
local ScreenPosition, Vis = Camera:WorldToViewportPoint(Head.Position);
if Vis then
local Color = v.TeamColor == LocalPlayer.TeamColor and Green or Red;

local ScreenPositionUpper = Camera:WorldToViewportPoint(Head.CFrame * CFrame.new(0, Head.Size.Y, 0).p);
local Scale = Head.Size.Y / 2;

if Options.ShowName.Value then
NameTag.Visible = true;
NameTag.Text = v.Name;
NameTag.Size = Options.TextSize.Value;
NameTag.Outline = Options.TextOutline.Value;
NameTag.Position = Vector2.new(ScreenPositionUpper.X, ScreenPositionUpper.Y);
NameTag.Color = Color;
if Drawing.Fonts then -- CURRENTLY SYNAPSE ONLY :MEGAHOLY:
NameTag.Font = Drawing.Fonts.UI;
end
else
NameTag.Visible = false;
end
if Options.ShowDistance.Value or Options.ShowHealth.Value then
DistanceTag.Visible = true;
DistanceTag.Size = Options.TextSize.Value - 1;
DistanceTag.Outline = Options.TextOutline.Value;
DistanceTag.Color = Color3.new(1, 1, 1);
if Drawing.Fonts then -- CURRENTLY SYNAPSE ONLY :MEGAHOLY:
NameTag.Font = Drawing.Fonts.UI;
end

local Str = '';

if Options.ShowDistance.Value then
Str = Str .. Format('[%d] ', Distance);
end
if Options.ShowHealth.Value and Humanoid then
Str = Str .. Format('[%d/100]', Humanoid.Health / Humanoid.MaxHealth * 100);
end

DistanceTag.Text = Str;
DistanceTag.Position = Vector2.new(ScreenPositionUpper.X, ScreenPositionUpper.Y) + Vector2.new(0, NameTag.Size);
else
DistanceTag.Visible = false;
end
if Options.ShowDot.Value then
local Top = Camera:WorldToViewportPoint((Head.CFrame * CFrame.new(0, Scale, 0)).p);
local Bottom = Camera:WorldToViewportPoint((Head.CFrame * CFrame.new(0, -Scale, 0)).p);
local Radius = (Top - Bottom).y;

HeadDot.Visible = true;
HeadDot.Color = Color;
HeadDot.Position = Vector2.new(ScreenPosition.X, ScreenPosition.Y);
HeadDot.Radius = Radius;
else
HeadDot.Visible = false;
end
if Options.ShowTracers.Value then
Tracer.Visible = true;
Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y);
Tracer.To = Vector2.new(ScreenPosition.X, ScreenPosition.Y);
Tracer.Color = Color;
else
Tracer.Visible = false;
end
if Options.ShowBoxes.Value and HumanoidRootPart then
Box:Update(HumanoidRootPart.CFrame, Vector3.new(2, 3, 0) * (Scale * 2), Color);
else
Box:SetVisible(false);
end
else
NameTag.Visible = false;
DistanceTag.Visible = false;
Tracer.Visible = false;
HeadDot.Visible = false;

Box:SetVisible(false);
end
end
else
NameTag.Visible = false;
DistanceTag.Visible = false;
Tracer.Visible = false;
HeadDot.Visible = false;

Box:SetVisible(false);
end

shared.PlayerData[v.Name] = Data;
end
end
end

function Update()
for i, v in pairs(shared.PlayerData) do
if not Players:FindFirstChild(tostring(i)) then
GetTableData(v.Instances)(function(i, obj)
obj.Visible = false;
obj:Remove();
v.Instances[i] = nil;
end)
shared.PlayerData[i] = nil;
end
end

local CX = Menu:GetInstance'CrosshairX';
local CY = Menu:GetInstance'CrosshairY';
if Options.Crosshair.Value then
CX.Visible = true;
CY.Visible = true;

CX.To = Vector2.new((Camera.ViewportSize.X / 2) - 8, (Camera.ViewportSize.Y / 2));
CX.From = Vector2.new((Camera.ViewportSize.X / 2) + 8, (Camera.ViewportSize.Y / 2));
CY.To = Vector2.new((Camera.ViewportSize.X / 2), (Camera.ViewportSize.Y / 2) - 8);
CY.From = Vector2.new((Camera.ViewportSize.X / 2), (Camera.ViewportSize.Y / 2) + 8);
else
CX.Visible = false;
CY.Visible = false;
end

if Options.MenuOpen.Value and MenuLoaded then
local MLocation = GetMouseLocation();
shared.MenuDrawingData.Instances.Main.Color = Color3.fromHSV(tick() * 24 % 255/255, 1, 1);
local MainInstance = Menu:GetInstance'Main';
local Values = {
MainInstance.Position.X;
MainInstance.Position.Y;
MainInstance.Position.X + MainInstance.Size.X;
MainInstance.Position.Y + MainInstance.Size.Y;
};
if MainInstance and MouseHoveringOver(Values) then
Debounce.CursorVis = true;
-- GUIService:SetMenuIsOpen(true);
Menu:UpdateMenuInstance'Cursor1'{
Visible = true;
From = Vector2.new(MLocation.x, MLocation.y);
To = Vector2.new(MLocation.x + 5, MLocation.y + 6);
}
Menu:UpdateMenuInstance'Cursor2'{
Visible = true;
From = Vector2.new(MLocation.x, MLocation.y);
To = Vector2.new(MLocation.x, MLocation.y + 8);
}
Menu:UpdateMenuInstance'Cursor3'{
Visible = true;
From = Vector2.new(MLocation.x, MLocation.y + 6);
To = Vector2.new(MLocation.x + 5, MLocation.y + 5);
}
else
if Debounce.CursorVis then
Debounce.CursorVis = false;
-- GUIService:SetMenuIsOpen(false);
Menu:UpdateMenuInstance'Cursor1'{Visible = false};
Menu:UpdateMenuInstance'Cursor2'{Visible = false};
Menu:UpdateMenuInstance'Cursor3'{Visible = false};
end
end
if MouseHeld then
if Dragging then
DraggingWhat.Slider.Position = Vector2.new(math.clamp(MLocation.X, DraggingWhat.Line.From.X, DraggingWhat.Line.To.X), DraggingWhat.Slider.Position.Y);
local Percent = (DraggingWhat.Slider.Position.X - DraggingWhat.Line.From.X) / ((DraggingWhat.Line.To.X - DraggingWhat.Line.From.X));
local Value = CalculateValue(DraggingWhat.Min, DraggingWhat.Max, Percent);
DraggingWhat.Option(Value);
elseif DraggingUI then
Debounce.UIDrag = true;
local Main = Menu:GetInstance'Main';
local MousePos = GetMouseLocation();
Main.Position = MousePos + DragOffset;
end
else
Dragging = false;
if DraggingUI and Debounce.UIDrag then
Debounce.UIDrag = false;
DraggingUI = false;
CreateMenu(Menu:GetInstance'Main'.Position);
end
end
if not Debounce.Menu then
Debounce.Menu = true;
ToggleMenu();
end
elseif Debounce.Menu and not Options.MenuOpen.Value then
Debounce.Menu = false;
ToggleMenu();
end
end

RunService:UnbindFromRenderStep(GetDataName);
RunService:UnbindFromRenderStep(UpdateName);

RunService:BindToRenderStep(GetDataName, 1, UpdatePlayerData);
RunService:BindToRenderStep(UpdateName, 1, Update);
end)
ctrlclicktp.MouseButton1Down:connect(function()
loadstring(game:GetObjects("rbxassetid://509249639")[1].Source)()
end)
noclip.MouseButton1Down:connect(function()
nam = game:GetService("Players").LocalPlayer.Name
 
game:GetService('RunService').Stepped:connect(function()
for a, b in pairs(game.Workspace:GetChildren()) do
if b.Name == nam then
for i, v in pairs(game.Workspace[nam]:GetChildren()) do
if v:IsA("BasePart") then
v.CanCollide = false
 
end
end
end
end
end)
 
 
Workspace[nam].Head.Changed:connect(function()
for a, b in pairs(game.Workspace:GetChildren()) do
if b.Name == nam then
for i, v in pairs(game.Workspace[nam]:GetChildren()) do
if v:IsA("BasePart") then
v.CanCollide = false
 
end
end
end
end
end)
end)
aimlock.MouseButton1Down:connect(function()
--made by Avexus#1234 discord from MrStuperd btw and DO NOT PRESS DELETE ;) GUI aimbot_toggled

local UIS = game:GetService('UserInputService')
local RS = game:GetService('RunService')
local Players = game:GetService('Players')
local StarterGui = game:GetService('StarterGui')
local Player = Players.LocalPlayer
local Studio = RS:IsStudio()
local PlayerGui = RS:IsStudio() and Player:WaitForChild('PlayerGui') or game.CoreGui
local Mouse = Player:GetMouse()
local old_icon = Mouse.Icon
local Camera = workspace.CurrentCamera
targetpart = 'Head' -- Don't change this.
-- It can be changed with the targetpart_change hotkey ingame.
local target
local target_old
local alert = false
local lockedon = false
local settingkey = false
local upvals = nil
local val = 1
local windows = {}
local function hb() RS.Heartbeat:wait() end

local version = 1.25
local Spawn = nil or game.PlaceId == 292439477 and workspace:WaitForChild('Lobby',2):WaitForChild('Spawn1',2)
local spawned = false

script.Name = 'GameSense!'
Mouse.TargetFilter = Camera

-- hotkey
toggle_aim = Enum.UserInputType.MouseButton2
toggle_aimbot = Enum.KeyCode.Delete
toggle_trigger = Enum.KeyCode.Delete
toggle_esp = Enum.KeyCode.Delete
toggle_gui = Enum.KeyCode.Delete
toggle_bottompos = Enum.KeyCode.Delete
toggle_performance = Enum.KeyCode.Delete
toggle_bones = Enum.KeyCode.Delete
toggle_chams = Enum.KeyCode.Delete
toggle_tracers = Enum.KeyCode.Delete
toggle_boxes = Enum.KeyCode.Delete
toggle_font = Enum.KeyCode.Delete
ffatoggle = Enum.KeyCode.Delete
targetpart_change = Enum.KeyCode.Delete
priority_toggle = Enum.KeyCode.Delete
sethotkey = Enum.KeyCode.Delete
-- aim fov
fov_increase = Enum.KeyCode.KeypadPlus
fov_decrease = Enum.KeyCode.KeypadMinus
-- aim sens (how smooth your crosshair will move)
sens_increase = Enum.KeyCode.RightBracket
sens_decrease = Enum.KeyCode.LeftBracket

-- parts
parts = {
	'Head';
	'Torso'
}

fonts = {
	Enum.Font.SourceSansBold,
	Enum.Font.Cartoon,
	Enum.Font.Arcade,
	Enum.Font.SciFi,
	Enum.Font.Fantasy,
	Enum.Font.Code,
	Enum.Font.Highway,
	Enum.Font.Bodoni
}

textSet = false

currentfont = 1
ffa = true
hidden = false
performancemode = true
-- aim
fov = 6
sens = .25
drop = .4
aim_toggled = false
bottompos = true
aim_priority = 2
-- [2] FOV or [1] Distance
aimingcolor = Color3.fromRGB(0,165,255)
aimbot_toggled = true
aim_line = true
locksoundid = 538769304
mouseiconid =  18671553

-- trigger
trigger_toggled = false
trigger_delay = 1/20

-- esp
esp_toggled = false
esp_bones = false
esp_chams = false
esp_tracers = false
-- item_esp (coming soon)
linesize = 1
showdists = true
textsize = 14
textoffset = 20
visiblecolor = Color3.fromRGB(38,255,99)
hiddencolor = Color3.fromRGB(255,37,40)
headboxsize = 4
headboxaimsize = 6
headboxshape = 'diamond'
-- rectangle or diamond

-- box esp
bounding_box = true
-- box_pointsize = 0 [UNUSED]
box_line_size = 1
-- box_line_size_visible = 2 [UNUSED]

local GUI = Instance.new('ScreenGui',PlayerGui)
GUI.Name = 'GameSense '..version
GUI.ResetOnSpawn = false

ESP = Instance.new('Folder',GUI)
ESP.Name = 'ESP'
local Bottom = Instance.new('Frame',ESP)
Bottom.Name = 'Bottom'
Bottom.BackgroundTransparency = 1
Bottom.Size = UDim2.new(0,1,0,1)
Bottom.Position = UDim2.new(.5,0,1,1)

local Status = Instance.new('TextLabel',GUI)
Status.Name = 'Status'
Status.BackgroundTransparency = 1
Status.Size = UDim2.new(0,500,0,50)
Status.Position = UDim2.new(.5,-250,.85,0)
Status.TextSize = 0
Status.Font = Enum.Font.SourceSansBold
Status.TextColor3 = Color3.new(1,1,1)
Status.TextStrokeColor3 = Color3.new(0,0,0)
Status.TextStrokeTransparency = .6
Status.Text = 'On Standby'
Status.ZIndex = 50

local Credits = Status:Clone()
Credits.Name = 'Credits'
Credits.Parent = GUI
Credits.Position = UDim2.new(-1000000,-1000000,-1000000,-1000000)
Credits.TextSize = 0
Credits.Text = 'GameSense '..version..' by Avexus!'

local FovGui = Instance.new('ImageLabel',GUI)
FovGui.Name = 'FovGui'
FovGui.Image = 'rbxassetid://324848180'
FovGui.Size = UDim2.new(0,(Camera.ViewportSize.X/(90/fov))*2,0,(Camera.ViewportSize.X/(90/fov))*2)
FovGui.Position = UDim2.new(0.5,-FovGui.AbsoluteSize.X/2,0.5,-FovGui.AbsoluteSize.Y/2)
FovGui.BackgroundTransparency = 1
FovGui.ImageTransparency = 0.9
FovGui.ImageColor3 = Color3.new(1,0,0)

local Indicator = Instance.new('TextLabel',GUI)
Indicator.Name = 'Indicator'
Indicator.Font = Enum.Font.SourceSans
Indicator.TextSize = 0
Indicator.TextXAlignment = Enum.TextXAlignment.Center
Indicator.TextYAlignment = Enum.TextYAlignment.Center
Indicator.TextStrokeTransparency = 1
Indicator.Text = aim_priority>1 and 'FOV: '..fov or 'Distance'

local SensAdjust = Instance.new('TextBox',GUI)
SensAdjust.Name = 'SensAdjust'
SensAdjust.Font = Enum.Font.SourceSans
SensAdjust.BackgroundTransparency = .75
SensAdjust.BackgroundColor3 = Color3.new(0,0,0)
SensAdjust.BorderColor3 = Color3.new(1,1,1)
SensAdjust.Size = UDim2.new(0,50,0,20)
SensAdjust.TextStrokeTransparency = 1
SensAdjust.TextColor3 = Color3.new(1,1,1)
SensAdjust.TextSize = 0
SensAdjust.PlaceholderText = 'Sens'
SensAdjust.Text = tonumber(sens)
SensAdjust.Position = Credits.Position + UDim2.new(0,250,0,75)

local SensLabel = Instance.new('TextLabel',SensAdjust)
SensLabel.Name = 'SensLabel'
SensLabel.Font = Enum.Font.SourceSans
SensLabel.Size = UDim2.new(1,0,1,0)
SensLabel.BackgroundTransparency = 1
SensLabel.TextSize = 0
SensLabel.TextColor3 = Color3.new(1,1,1)
SensLabel.TextStrokeColor3 = Color3.new(0,0,0)
SensLabel.TextStrokeTransparency = 1
SensLabel.Text = 'Sens:'
SensLabel.Position = UDim2.new(-1,0,0,0)
SensLabel.TextXAlignment = Enum.TextXAlignment.Left

local FovAdjust = SensAdjust:Clone()
FovAdjust.Parent = GUI
FovAdjust.PlaceholderText = 'FOV'
FovAdjust.Name = 'FovAdjust'
FovAdjust.Text = tonumber(fov)
FovAdjust.Position = SensAdjust.Position + UDim2.new(0,0,0,20)
FovAdjust.SensLabel.Name = 'FovLabel'
FovAdjust.FovLabel.Text = 'Fov:'

local DropAdjust = SensAdjust:Clone()
DropAdjust.Parent = GUI
DropAdjust.PlaceholderText = 'Drop'
DropAdjust.Name = 'DropAdjust'
DropAdjust.Text = tonumber(drop)
DropAdjust.Position = SensAdjust.Position + UDim2.new(0,0,0,40)
DropAdjust.SensLabel.Name = 'DropLabel'
DropAdjust.DropLabel.Text = 'Drop:'

local KeysList = Instance.new('TextLabel',GUI)
KeysList.Name = 'KeysList'
KeysList.Font = Enum.Font.SourceSans
KeysList.TextStrokeTransparency = .6
KeysList.TextSize = 0
KeysList.TextColor3 = Color3.new(1,1,1)
KeysList.Size = UDim2.new(0,0,1,0)
KeysList.Position = UDim2.new(0,5,0,-280)
KeysList.BackgroundTransparency = 1
KeysList.Active = false

local n = 0

spawn(function()
	while Status do
		Indicator.TextColor3 = Color3.fromHSV(n,.5,1)
		FovGui.ImageColor3 = Indicator.TextColor3
		if not textSet then
		if aim_toggled and target then
			Status.TextColor3 = aimingcolor
			Status.Text = ('Aiming at '..target.Name)
		else
			Status.TextColor3 = Color3.fromHSV(n,.5,1)
			Status.Text = 'On Standby'
		end
		end
		n = (n+.005)%1
		hb()
	end
end)

SensAdjust.InputEnded:Connect(function() if SensAdjust.Text~='' then sens = tonumber(SensAdjust.Text)>0 and tonumber(SensAdjust.Text) or sens end end)
FovAdjust.InputEnded:Connect(function() if FovAdjust.Text~='' then fov = tonumber(FovAdjust.Text)>0 and tonumber(FovAdjust.Text) or fov
FovGui:TweenSize(UDim2.new(0,(Camera.ViewportSize.X/(90/fov))*2,0,(Camera.ViewportSize.X/(90/fov))*2),Enum.EasingDirection.InOut,Enum.EasingStyle.Quad,.1,true) end end)
DropAdjust.InputEnded:Connect(function() if DropAdjust.Text~='' then drop = tonumber(DropAdjust.Text)>=0 and tonumber(DropAdjust.Text) or drop end end)

local function distfromspawn(x)
	if Spawn then
		return x:DistanceFromCharacter(Spawn.Position)
	else
		return 201
	end
end

local function setText(text)
	spawn(function()
	textSet = true
	Status.Text = text
	Status.TextColor3 = Color3.new(1,1,1)
	wait(#text/4)
	textSet = false
	end)
end

local function playsound(id)
	local sound = Instance.new('Sound',Camera)
	sound.Volume = 3
	sound:Play()
	game:GetService('Debris'):AddItem(sound,5)
end


local function DrawLine(Folder,P1,P2,Thickness,Color,LineTransparency,BorderThickness,BorderColor)
	-- Declare variables
	local Point1,Point2 = P1.Position,P2.Position
	if Point1 and Point2 then
	local X,Y = Camera.ViewportSize.X, Camera.ViewportSize.Y
	local X1,X2 = (X * Point1.X.Scale + Point1.X.Offset + P1.Size.X.Offset/2), (X * Point2.X.Scale + Point2.X.Offset + P2.Size.X.Offset/2)
	local Y1,Y2 = (Y * Point1.Y.Scale + Point1.Y.Offset + P1.Size.Y.Offset/2), (Y * Point2.Y.Scale + Point2.Y.Offset + P2.Size.Y.Offset/2)
	local MidX,MidY = (X1+X2)/2, (Y1+Y2)/2
	-- Set defaults to prevent errors
	Thickness = Thickness or 1
	Color = Color or Color3.new(1,1,1)
	LineTransparency =  LineTransparency or 0
	BorderThickness = BorderThickness or 0
	BorderColor = BorderColor or Color3.new(0,0,0)
	-- Draw the line
	local Line = Folder:FindFirstChild(P1.Name..'-'..P2.Name) or Instance.new('Frame',Folder)
	Line.Visible = false
	Line.BackgroundTransparency = LineTransparency
	Line.BorderSizePixel = BorderThickness
	Line.BorderColor3 = BorderColor
	Line.Size = UDim2.new(0,(Vector2.new(X1,Y1) - Vector2.new(X2,Y2)).magnitude-1,0,Thickness)
	Line.Position = UDim2.new(0,MidX-Line.AbsoluteSize.X/2,0,MidY-Line.AbsoluteSize.Y)
	Line.BackgroundColor3 = Color
	Line.Rotation = math.deg(math.atan2((Y2-Y1),(X2-X1)))
	Line.Name = P1.Name..'-'..P2.Name
	Line.Visible = true
	return Line
	else
		return nil
	end
end

local function GetNearest(Mode)
	local lowest,nearest,gui = math.huge,nil,nil
	if Mode==1 then
	for _,plr in next,Players:GetPlayers() do 
		if plr.Name~=Player.Name and plr.Character~=nil and plr.Character:FindFirstChild(targetpart) then
			local dist = Player:DistanceFromCharacter(plr.Character[targetpart].Position)
			local ray = Ray.new(Player.Character.Head.Position,(plr.Character[targetpart].Position-Player.Character.Head.Position).unit*5000)
			local part,point = workspace:FindPartOnRayWithIgnoreList(ray,{Camera,Player.Character,unpack(windows)})
			local Z = Camera:WorldToScreenPoint(plr.Character[targetpart].Position).Z
			if part and part:IsDescendantOf(plr.Character) and Z>0 and dist < lowest and (ffa or plr.TeamColor~=Player.TeamColor) then lowest = dist nearest = plr.Character end
		end
	end
	elseif Mode==2 then
		for _,plr in next,Players:GetPlayers() do
			if plr.Name~=Player.Name and plr.Character~=nil and plr.Character:FindFirstChild(targetpart) then
				local pos = Camera:WorldToScreenPoint(plr.Character[targetpart].Position)
				local ray = Ray.new(Player.Character[targetpart].Position,(plr.Character[targetpart].Position-Player.Character[targetpart].Position).unit*2048)
				local part,point = workspace:FindPartOnRayWithIgnoreList(ray,{Camera,Player.Character,unpack(windows)})
				local dist = (Vector2.new(Mouse.X,Mouse.Y)-Vector2.new(pos.X,pos.Y)).magnitude
				if part and part:IsDescendantOf(plr.Character) and pos.Z>0 and dist <= Camera.ViewportSize.X/(90/fov) and dist < lowest and (ffa or plr.TeamColor~=Player.TeamColor) then lowest = dist nearest = plr.Character end
			end
		end
	end
	return nearest
end
	
Mouse.Move:Connect(function()
	cursor = ESP:FindFirstChild('Cursor') or Instance.new('Frame',ESP)
	cursor.Name = 'Cursor'
	cursor.BackgroundTransparency = 1
	cursor.Size = UDim2.new(0,1,0,1)
	cursor.Position = UDim2.new(0,Mouse.X,0,Mouse.Y)
end)

UIS.InputBegan:Connect(function(Input)
	if Input.KeyCode == toggle_aim or Input.UserInputType == toggle_aim then
		aim_toggled = true
		warn('GS: aim toggled',aim_toggled and 'on' or 'off')
		alert = true
		while aim_toggled and aimbot_toggled do
			target = GetNearest(aim_priority)
			if target then
				local dist = Player:DistanceFromCharacter(target[targetpart].Position)
				local headpos = Camera:WorldToScreenPoint(target[targetpart].Position+Vector3.new(0,dist/(100/drop),0))
				local moveto = Vector2.new((headpos.X-Mouse.X)*sens,(headpos.Y-Mouse.Y)*sens)
				aimpos = GUI:FindFirstChild('AimPos') or Instance.new('Frame',GUI)
				if not GUI:FindFirstChild('AimPos') then
				aimpos.Name = 'AimPos'
				aimpos.BorderSizePixel = 1
				aimpos.BorderColor3 = Color3.new(0,0,0)
				aimpos.BackgroundTransparency = 0
				aimpos.BackgroundColor3 = Color3.new(1,1,1)
				aimpos.Rotation = 45
				aimpos.ZIndex = 4
				aimpos.Size = UDim2.new(0,3,0,3)
				end
				aimpos.Position = UDim2.new(0,headpos.X-aimpos.AbsoluteSize.X/2,0,headpos.Y-aimpos.AbsoluteSize.Y/2)
				aimpos.Visible = true
				mousemoverel(moveto.X,moveto.Y)
				if alert or target~=target_old then
					playsound(locksoundid)
					print('GS: locked onto',target.Name)
					lockedon = true
					alert = false
				end
			end
			RS.Heartbeat:wait()
			target_old = target
			if aimpos then
				aimpos.Visible = false
			end
		end
		lockedon = false
	elseif Input.KeyCode == toggle_trigger then
		trigger_toggled = not trigger_toggled
		setText('Toggled TriggerBot '..(trigger_toggled and 'On' or 'Off'))
		Notification({Title='TriggerBot';Text='TriggerBot was toggled '..(trigger_toggled and 'On' or 'Off');Duration=2;})
		warn('trigger toggled',trigger_toggled and 'on' or 'off')
		local Box = Instance.new('SelectionBox',PlayerGui)
		Box.Color3 = Color3.new(1,0,0)
		Box.LineThickness = .05
		Box.Adornee = nil
		if trigger_delay>0 then wait(trigger_delay) end
		while trigger_toggled do
		local Target = Mouse.Target
		local plr = Players:FindFirstChild(Target.Parent.Name)
		if Target and Target.Parent and plr~=nil and plr~=Player and ffa or plr~=nil and plr.TeamColor~=Player.TeamColor then
			Box.Adornee = Mouse.Target
			mouse1press()
			wait()
			mouse1release()
		end
		RS.Heartbeat:wait()
		end
		Box:Destroy()
	elseif Input.KeyCode == toggle_esp then
		esp_toggled = not esp_toggled
		Notification({Title='ESP';Text='ESP was toggled '..(esp_toggled and 'On' or 'Off');Duration=2;})
		setText('Toggled ESP '..(esp_toggled and 'On' or 'Off'))
	elseif Input.KeyCode == toggle_aimbot then
		aimbot_toggled = not aimbot_toggled	
		Notification({Title='AimBot';Text='AimBot was toggled '..(aimbot_toggled and 'On' or 'Off');Duration=2;})
		setText('Toggled AimBot '..(aimbot_toggled and 'On' or 'Off'))
	elseif Input.KeyCode == fov_increase then
		fov = fov + .5
		FovAdjust.Text = tonumber(fov)
		if FovGui.Visible then
			FovGui:TweenSize(UDim2.new(0,(Camera.ViewportSize.X/(90/fov))*2,0,(Camera.ViewportSize.X/(90/fov))*2),Enum.EasingDirection.InOut,Enum.EasingStyle.Quad,.1,true)
		end
		setText('Aim FOV: '..fov)
	elseif Input.KeyCode == fov_decrease and fov>0 then
		fov = fov - .5
		FovAdjust.Text = tonumber(fov)
		if FovGui.Visible then
			FovGui:TweenSize(UDim2.new(0,(Camera.ViewportSize.X/(90/fov))*2,0,(Camera.ViewportSize.X/(90/fov))*2),Enum.EasingDirection.InOut,Enum.EasingStyle.Quad,.1,true)
		end
		setText('Aim FOV: '..fov)
	elseif Input.KeyCode == sens_increase then
		sens = sens + .05
		SensAdjust.Text = tonumber(sens)
		setText('Sens: '..sens)
	elseif Input.KeyCode == sens_decrease then
		sens = sens - .05
		SensAdjust.Text = tonumber(sens)
		setText('Sens: '..sens)
	elseif Input.KeyCode == targetpart_change then
		val = val+1
		targetpart = val<=#parts and parts[val] or parts[1]
		if parts[1]==targetpart then val = 1 end
		Notification({Title='Target Part';Text='Target part set to '..targetpart;Duration=2;})
		setText('Target Part: '..targetpart)
	elseif Input.KeyCode == ffatoggle then
		ffa = not ffa
		Notification({Title='FFA Mode';Text='FFA Mode is '..(ffa and 'Enabled' or 'Disabled');Duration=2;})
		setText('FFA Mode: '..(ffa and 'Enabled' or 'Disabled'))
	elseif Input.KeyCode == priority_toggle then
		aim_priority = aim_priority+1>2 and 0 or 1
		aim_priority = aim_priority+1
		FovGui.Visible = aim_priority>1
		setText('Aim Priority: '..(aim_priority==1 and 'Distance' or 'FOV'))
	elseif Input.KeyCode == toggle_bones then
		esp_bones = not esp_bones
		if not esp_bones then
		for _,v in next,ESP:GetDescendants() do
			if v:IsA('Frame') and v.Name:match('-') then
				v:Destroy()
			end
		end
		end
		setText('Toggled ESP Bones '..(esp_bones and 'Enabled' or 'Disabled'))
	elseif Input.KeyCode == toggle_gui then
		hidden = not hidden
		for _,gui in next,GUI:GetDescendants() do
			if gui:IsA('GuiObject') and not hidden and not gui.Visible then
				gui.Visible = true
				Mouse.Icon = 'rbxassetid://'..mouseiconid
			elseif gui:IsA('GuiObject') and gui.Visible then
				gui.Visible = false
				esp_toggled = false
				Mouse.Icon = old_icon
			end
			end
		elseif Input.KeyCode == toggle_bottompos then
			bottompos = not bottompos
			if bottompos then
				Bottom.Position = UDim2.new(.5,0,1,1)
			end
		elseif Input.KeyCode == toggle_performance then
			performancemode = not performancemode
			setText('Performance Mode '..(performancemode and 'Enabled' or 'Disabled'))
		elseif Input.KeyCode == toggle_chams then
			esp_chams = not esp_chams
			setText('Chams '..(esp_chams and 'Enabled' or 'Disabled'))
		elseif Input.KeyCode == toggle_tracers then
			esp_tracers = not esp_tracers
			setText('Tracers '..(esp_chams and 'Enabled' or 'Disabled'))
		elseif Input.KeyCode == toggle_boxes then
			bounding_box = not bounding_box
			setText('Bounding Boxes '..(bounding_box and 'Enabled' or 'Disabled'))
		elseif Input.KeyCode == toggle_font then
				currentfont = (currentfont+1)>#fonts and 1 or currentfont+1
				for _,v in next,GUI:GetDescendants() do
					if v.Name~='KeysList' then
					if v:IsA('TextLabel') or v:IsA('TextButton') then
						v.Font = fonts[currentfont]
					end
					end
				end
		end
end)

UIS.InputEnded:Connect(function(Input)
	if Input.KeyCode == toggle_aim or Input.UserInputType == toggle_aim then
		aim_toggled = false
	end
end)

local function checkifspawned(x)
	spawned = false
	while not spawned and game.PlaceId==292439477 do
		spawned = distfromspawn(x)>200 and true or false
		wait(1/5)
	end
	spawned = true
end

checkifspawned(Player)
Player.CharacterAdded:Connect(function(c)
	checkifspawned(Player)
	
	for _,v in next,ESP:GetDescendants() do
		if v:IsA('Frame') and v.Name:match('-') then
			v:Destroy()
		end
	end
end)

Notification({Title='Aimbot '..version;Text='Loaded successfully.';Icon='rbxassetid://2572157833';Duration=10;})
wait(.5)

RS.RenderStepped:Connect(function()
	if cursor then
		FovGui.Position = cursor.Position-UDim2.new(0,FovGui.AbsoluteSize.X/2,0,FovGui.AbsoluteSize.Y/2)
		Indicator.Position = cursor.Position+UDim2.new(0,0,0,40)
	end
end)

Mouse.Button1Down:Connect(function()
	spawn(function()
		if FovGui.Visible then
			FovGui:TweenSize(UDim2.new(0,Camera.ViewportSize.X/(90/fov)*2.35,0,Camera.ViewportSize.X/(90/fov)*2.35),Enum.EasingDirection.InOut,Enum.EasingStyle.Quad,.1,true)
			wait(.1)
			FovGui:TweenSize(UDim2.new(0,Camera.ViewportSize.X/(90/fov)*2,0,Camera.ViewportSize.X/(90/fov)*2),Enum.EasingDirection.InOut,Enum.EasingStyle.Quad,.1,true)
		end
	end)
end)

while true do
	Indicator.Text = (aim_priority>1 and 'FOV: '..fov or 'Distance') ..'\nSens: '..sens..(aim_toggled and '\nAiming' or '')
	if not bottompos then Bottom.Position = cursor.Position end
	if esp_toggled then
	for _,v in next,ESP:children() do
		if v~=Bottom and not Players:FindFirstChild(v.Name) then
			v:Destroy()
		end
	end
	for _,v in next,Players:GetPlayers() do
		local Char = v.Character
		if Char and spawned and v~=Player and Char:FindFirstChild(targetpart) and distfromspawn(v)>100 then
			if ffa or v.TeamColor~=Player.TeamColor then
			local X = Camera:GetPartsObscuringTarget({Camera.CFrame.p,Char[targetpart].CFrame.p},{v.Character,Char,Camera,unpack(windows)})
			local Dist = Player:DistanceFromCharacter(Char:FindFirstChild(targetpart).Position)
			local Color = hiddencolor
			local Folder = ESP:FindFirstChild(v.Name) or Instance.new('Folder',ESP)
			Folder.Name = v.Name
			-- ESP
			local Head = Folder:FindFirstChild('Head') or Instance.new('Frame',Folder)
			if not Folder:FindFirstChild('Head') then
			Head.Name = 'Head'
			Head.BorderSizePixel = 1
			Head.BorderColor3 = Color3.new(0,0,0)
			Head.BackgroundTransparency = 0
			end
			Head.BackgroundColor3 = #X>0 and hiddencolor or #X==0 and visiblecolor
			Head.Rotation = headboxshape=='diamond' and 45 or 0
			Head.ZIndex = 3
			local HP = Folder:FindFirstChild('HP') or Instance.new('TextLabel',Folder)
			if not Folder:FindFirstChild('HP') then
			HP.Name = 'HP'
			HP.TextTransparency = Head.BackgroundTransparency-.4
			HP.Font = fonts[currentfont]
			HP.TextStrokeTransparency = .6
			HP.BackgroundTransparency = 1
			HP.TextSize = 14
			end
			HP.Text = showdists and Char.Name..'\n'..math.floor(Dist+.5) or Char.Name
			if aim_toggled and target==Char then
				Head.Size = UDim2.new(0,headboxaimsize,0,headboxaimsize)
				Head.BackgroundColor3 = aimingcolor
				HP.Text = showdists and '['..Char.Name..']'..'\n'..math.floor(Dist+.5) or '['..Char.Name..']'
				HP.TextSize = 16
			else
				Head.Size = UDim2.new(0,headboxsize,0,headboxsize)
			end
			HP.TextColor3 = Head.BackgroundColor3
			local toScreen = Camera:WorldToScreenPoint(Char[targetpart].CFrame.p)
			if #X==0 then Color = visiblecolor end
			Head.Position = UDim2.new(0,toScreen.X-Head.Size.X.Offset/2,0,toScreen.Y-Head.Size.Y.Offset/2)
			HP.Position = Head.Position-UDim2.new(0,0,0,textoffset)
			if esp_tracers then
			local Line = DrawLine(Folder,ESP.Bottom,Head,linesize,Head.BackgroundColor3,.75,1,Color3.new(0,0,0))
				Line.Visible = Head.Visible
			else
				local imtired = Folder:FindFirstChild(ESP.Bottom.Name..'-'..Head.Name)
				if imtired then
					imtired:Destroy()
				end
			end
			if toScreen.Z<=0 then Head.Visible = false else Head.Visible = true end
			HP.Visible = Head.Visible
			if Char:FindFirstChild('Humanoid') and Char.Humanoid.RigType==Enum.HumanoidRigType.R6 then
			local Neck = Folder:FindFirstChild('Neck') or Instance.new('Frame',Folder)
			Neck.Name = 'Neck'
			Neck.ZIndex = 2
			if Char['Torso']~=nil then
			local Pos = (Char.Torso.CFrame*CFrame.new(0,.8,0)).p
			local X,Y,Z = Camera:WorldToScreenPoint(Pos).X,Camera:WorldToScreenPoint(Pos).Y,Camera:WorldToScreenPoint(Pos).Z
			Neck.Position = UDim2.new(0,X,0,Y)
			Neck.BorderSizePixel = 0
			if Z<=0 then Neck.Visible = false else Neck.Visible = true end
			else
				Neck.Visible = false
			end
			--
			local Pelvis = Folder:FindFirstChild('Pelvis') or Instance.new('Frame',Folder)
			Pelvis.Name = 'Pelvis'
			Pelvis.ZIndex = 2
			Pelvis.BorderSizePixel = 0
			if Char['Torso']~=nil then
			local Pos = (Char.Torso.CFrame*CFrame.new(0,-1,0)).p
			local X,Y,Z = Camera:WorldToScreenPoint(Pos).X,Camera:WorldToScreenPoint(Pos).Y,Camera:WorldToScreenPoint(Pos).Z
			Pelvis.Position = UDim2.new(0,X,0,Y)
			if Z<=0 then Pelvis.Visible = false else Pelvis.Visible = true end
			else
				Pelvis.Visible = false
			end
			--
			local RightFoot = Folder:FindFirstChild('Right Foot') or Instance.new('Frame',Folder)
			RightFoot.Name = 'Right Foot'
			RightFoot.ZIndex = 2
			RightFoot.BorderSizePixel = 0
			if Char['Right Leg']~=nil then
			local Pos = (Char['Right Leg'].CFrame*CFrame.new(0,-1,0)).p
			local X,Y,Z = Camera:WorldToScreenPoint(Pos).X,Camera:WorldToScreenPoint(Pos).Y,Camera:WorldToScreenPoint(Pos).Z
			RightFoot.Position = UDim2.new(0,X,0,Y)
			if Z<=0 then RightFoot.Visible = false else RightFoot.Visible = true end
			else
				RightFoot.Visible = false
			end
			--
			local LeftFoot = Folder:FindFirstChild('Left Foot') or Instance.new('Frame',Folder)
			LeftFoot.Name = 'Left Foot'
			if Char['Left Leg']~=nil then
			local Pos = (Char['Left Leg'].CFrame*CFrame.new(0,-1,0)).p
			local X,Y,Z = Camera:WorldToScreenPoint(Pos).X,Camera:WorldToScreenPoint(Pos).Y,Camera:WorldToScreenPoint(Pos).Z
			LeftFoot.Position = UDim2.new(0,X,0,Y)
			LeftFoot.BorderSizePixel = 0
			if Z<=0 then LeftFoot.Visible = false else LeftFoot.Visible = true end
			else
				LeftFoot.Visible = false
			end
			--
			local RightHand = Folder:FindFirstChild('Right Hand') or Instance.new('Frame',Folder)
			RightHand.Name = 'Right Hand'
			RightHand.ZIndex = 2
			RightHand.BorderSizePixel = 0
			if Char['Right Arm']~=nil then
			local Pos = (Char['Right Arm'].CFrame*CFrame.new(0,-1,0)).p
			local X,Y,Z = Camera:WorldToScreenPoint(Pos).X,Camera:WorldToScreenPoint(Pos).Y,Camera:WorldToScreenPoint(Pos).Z
			RightHand.Position = UDim2.new(0,X,0,Y)
			if Z<=0 then RightHand.Visible = false else RightHand.Visible = true end
			else
				RightHand.Visible = false
			end
			--
			local LeftHand = Folder:FindFirstChild('Left Hand') or Instance.new('Frame',Folder)
			LeftHand.Name = 'Left Hand'
			LeftHand.ZIndex = 2
			LeftHand.BorderSizePixel = 0
			if Char['Left Arm']~=nil then
			local Pos = (Char['Left Arm'].CFrame*CFrame.new(0,-1,0)).p
			local X,Y,Z = Camera:WorldToScreenPoint(Pos).X,Camera:WorldToScreenPoint(Pos).Y,Camera:WorldToScreenPoint(Pos).Z
			LeftHand.Position = UDim2.new(0,X,0,Y)
			if Z<=0 then LeftHand.Visible = false else LeftHand.Visible = true end
			else
				LeftHand.Visible = false
			end
			-- draw joints
			if esp_bones then
			if Head.Visible then DrawLine(Folder,Head,Neck,1,Color3.new(1,1,1),Head.BackgroundTransparency) end
			if Neck.Visible then DrawLine(Folder,Neck,Pelvis,1,Color3.new(1,1,1),Head.BackgroundTransparency) end
			if Neck.Visible then DrawLine(Folder,Neck,RightHand,1,Color3.new(1,1,1),Head.BackgroundTransparency) end
			if Neck.Visible then DrawLine(Folder,Neck,LeftHand,1,Color3.new(1,1,1),Head.BackgroundTransparency) end
			if Pelvis.Visible then DrawLine(Folder,Pelvis,RightFoot,1,Color3.new(1,1,1),Head.BackgroundTransparency) end
			if Pelvis.Visible then DrawLine(Folder,Pelvis,LeftFoot,1,Color3.new(1,1,1),Head.BackgroundTransparency) end
			end
			end
			
			if esp_chams then
				for _,Part in next,Char:children() do
					if Part:IsA('BasePart') and Part.Name~='HumanoidRootPart' then
						local Adornment = Folder:FindFirstChild(Part.Name..'_Cham') or Instance.new('BoxHandleAdornment',Folder)
						if not Folder:FindFirstChild(Part.Name..'_Cham') then
						Adornment.Name = Part.Name..'_Cham'
						Adornment.Adornee = Part
						Adornment.AlwaysOnTop = true
						Adornment.Size = Part.Name=='Head' and Vector3.new(1,1,1) or Part.Size
						Adornment.ZIndex = 1
						end
						Adornment.Color3 = Head.BackgroundColor3
					end
				end
			else
				for _,v in next,Folder:GetDescendants() do
					if v.Name:match('Cham') then
						v:Destroy()
					end
				end
			end
			
			if bounding_box and Char:FindFirstChild('HumanoidRootPart') then
				local Box = Char:FindFirstChild('Box') or Instance.new('BillboardGui',Char)
				if not Char:FindFirstChild('Box') then
				Box.Name = 'Box'
				Box.Adornee = Char:FindFirstChild('HumanoidRootPart')
				Box.AlwaysOnTop = true
				Box.LightInfluence = 0
				Box.StudsOffset = Vector3.new(0,-Box.Adornee.Size.Y/4,0)
				Box.Size = UDim2.new(4,1,5,1)
				local Top = Instance.new('Frame',Box)
				Top.Size = UDim2.new(1,0,0,box_line_size)
				Top.BorderSizePixel = 0
				local Bot = Top:Clone()
				Bot.Position = UDim2.new(0,0,1,-box_line_size)
				Bot.Parent = Box
				local Left = Top:Clone()
				Left.Size = UDim2.new(0,1,1,0)
				Left.Parent = Box
				local Right = Left:Clone()
				Right.Position = UDim2.new(1,-box_line_size,0,0)
				Right.Parent = Box
				end
				for _,v in next,Box:children() do
					if v:IsA('Frame') then
						v.BackgroundColor3 = Head.BackgroundColor3
					end
				end
			else
				local Box = Char:FindFirstChild('Box')
				if Box then
					Box:Destroy()
				end
			end
			
			if lockedon and target and aim_line and ESP:FindFirstChild(target.Name) then
				DrawLine(ESP,cursor,ESP:FindFirstChild(target.Name).Head,1,Head.BackgroundColor3,.5)
			end
			
		else
			if ESP:FindFirstChild(v.Name) then
				ESP:FindFirstChild(v.Name):Destroy()
			end
			end
		else
			if ESP:FindFirstChild(v.Name) then
				ESP:FindFirstChild(v.Name):Destroy()
			end
		end
		end
	else
		for _,v in next,ESP:children() do
			if v:IsA('Folder') then
				v:Destroy()
			end
		end
	end
	if performancemode then
		wait(1/(workspace:GetRealPhysicsFPS()*.75))
	else
		RS.Stepped:wait()
	end
end

--[[ broken
spawn(function()
while script and game.PlaceId == 292439477 and workspace:FindFirstChild('Map') do
	windows = {}
	for _,v in next,workspace.Map:GetChildren() do
		if v.Name=='Window' then
			table.insert(windows,v)
		end
	end
	wait(2)
end
end)
--]]
end)
removemap.MouseButton1Down:connect(function()
while wait() do
for a,z in pairs(game:GetService("Workspace")["BuildStuff"]:GetDescendants()) do
z:Destroy()
end
end
end)
local Players = game:GetService'Players';
local LocalPlayer = Players.LocalPlayer;
local Camera = workspace.CurrentCamera;
local Dot = Vector3.new().Dot;
local Networks = {};

for i, v in pairs(debug.getregistry()) do
if typeof(v) == 'function' and islclosure(v) then
local ups = debug.getupvalues(v);
if ups.NWModule and ups.NWModule.FireServer then
Networks[#Networks + 1] = ups.NWModule;
end
end
end

local Net = Networks[1];

assert(#Networks ~= 0, 'No Network');

function SameTeam(P1, P2)
if P1 == P2 then
return false
end
if P1.Neutral or P2.Neutral then
return false
elseif P1.TeamColor == P2.TeamColor then
return true
end
return false
end

function GetPlayerClosestToMouse()
local Highest = {0, nil};

for i, v in pairs(Players:GetPlayers()) do
local Player = v;
local Character = Player.Character;
if Player ~= LocalPlayer and not SameTeam(Player, LocalPlayer) and Character then
local Head = Character:FindFirstChild'Head';
if Head then
local Direction = Camera.CFrame.lookVector.unit;
local Relative = Player.Character.Head.Position - Camera.CFrame.p;
local Unit = Relative.unit;

local DP = Dot(Direction, Unit);
if DP > Highest[1] then
Highest = {DP, Player};
end
end
end
end

return Highest[2];
end

local Active = true;
local Rand = Random.new();

for i, v in pairs(Networks) do
shared['oFireServer' .. tostring(v)] = shared['oFireServer' .. tostring(v)] or v.FireServer;
v.FireServer = function(...)
local Arguments = {...};

if Active and Arguments[2] == 'Damage' and typeof(Arguments[3]) == 'Instance' and Arguments[3]:IsA'ValueBase' then
return true;
end

return shared['oFireServer' .. tostring(v)](...);
end
end

game:GetService'UserInputService'.InputEnded:connect(function(Input)
if Input.UserInputType == Enum.UserInputType.Keyboard and Input.KeyCode == Enum.KeyCode.F3 then
Active = not Active;
elseif Active and Input.UserInputType == Enum.UserInputType.MouseButton1 then
spawn(function()
wait(.05);
local Player = GetPlayerClosestToMouse();
if Player then
local Character = Player.Character;
if Character then
local Humanoid = Character:FindFirstChildOfClass'Humanoid';
local Head = Character:FindFirstChild'Head';
if Humanoid and Humanoid.Health > 0 and Head then
Net:FireServer('Damage', Humanoid, Head, Head.Position, Head.Position + Vector3.new(Rand:NextNumber() / 10, .25 + (Rand:NextNumber() / 10), Rand:NextNumber() / 10))
end
end
end
end);
end
end)
